６章３節
初期のルーティングは
get 'static_pages/home'

と言ったようになっており、ルーティングの参照の挙動としては
まず一番最初にコントローラーを探す
コントローラーのアクションhomeがあった場合、そのアクションの中身を参照する。

def home
end
の中身が何も書いていなかったら
  アクション名と同じコントローラー/アクション.html.erbを参照する。
  この場合。static_pages/home(.html.erb)が参照される


6章４節
手動でページの追加手順


６章５節
レイアウトファイルとDRY
yieldが該当箇所に置き換えられて自動的に読み込まれるようになっている。
ヘッダーに使用されている
<%=yield(:title)%>
の(:title)の部分は、provideに対応しており、これは各ビューのprovideの引数を受け取っている。いわゆるparamsと似たような構造と考えても良い。例えばhomeであれば
<%=provide(:title, 'home')%>
と言ったようになる

６章5節番外：
Railsに必要なRubyの知識を学ぶ＆ヘルパー

ヘルパーは、app/helpersの中にあり、この中にヘルパーを定義することができる。

ヘルパーは、いわゆるメソッド的な役割と同じで、html cssに関しても、同じ処理を繰り返すものであれば、基本的にヘルパーにまとめておくことで、便利に再利用をすることができる。

また、ヘルパーに直接htmlを指定することができ、spanやdiv、h1などを生成する最便利なものではcontent_tagなどが存在する
def hogehoge
  content_tag(:span, 'hogehogehogera', style:'color:red;')
end
のように、
content_tag(要素名,'文字列', スタイルやクラスなど)
とすることが可能で、指定する際は
<%=hogehoge%>
などとする

7章１節：
レイアウトを作成する

<!-- [if lt IE 9] -->
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<!-- ![endif] -->
これは条件付きコメントというもので、IEのみサポートされている特殊な書き方になっている。

今回はbootstrapを適応させて、簡単に見た目をスタイリングすることとした。
ヘッダーにはnavbar navba-fixed-top navbar-inverseなどを使い、ナビケーションバーにしつつ、コンテンツは中央揃えにしながらも上よりにしてある。
もちろん中はcontainerで囲ってあげて、その後にリンクを仕込ませる。危うやなのでメモすると

link_to "文字", 'リンク先', id: "logo"
と言った感じで指定でき、idの部分はclassにすることも可能。
なお、rubyにおいて引数の（）は省略することができ、更にjsと似たような感じで書くと
.link_to("文字","リンク先",{id:"logo"})
と言ったような感じになる

画像の引数の指定は少々複雑で、
<%=link_to image_tag("rails.png", alt: "Rails"), 'http://rubyonrails.org'%>
と言ったような指定をすることができこの場合は

link_to "文字や（画像,alt）の指定ができる", "飛び先", id classなど

と言ったしていの順番になる。画像が指定できる理由は、返還後
<a href="#"><img src="" alt=""></a>
のようになるためである。

bootstrapを安全に運用していくためには、バージョン指定は必須。指定の間違いの内容に確認をしっかりすること。今回は
gem 'bootstrap-saass', '3.3.1'
を導入した。またbootstrapと関連性の強いsprocketsも導入した。

７章２節
独自CSSの追加
特筆事項なし
あるとしたら、bootstrapを使用している場合、初期スタイリングと被らないように気をつけながらスタイリングする必要がある。

また、ページ全体に適応するのであれば、別途custom.css.scssなどとして、application全体のcssとbootstrap専用のcssとを区別してあげる必要がある。




７章３節：パーシャル・Sassで記述の簡素化
パーシャルを利用する際は、
render 'controller/view'
としてあげる必要があり、パーシャルで作成する際には
_view.html.erb
としてあげる必要がある。

アセットパイプライン
  アセットディレクトリについて

  アセットディレクトリ・マニフェストファイル・プリプロセッサエンジンというものがある。

  アセットディレクトリ
    railsバージョン4以上ではリソース（アセット：画像・CSS・JS等）の管理用に３種類のディレクトリが用意されている。

    app/assets:一番一般的に使う現在のアプリケーション用のアセット
    lib/assets：開発チームによって作成されたライブラリ用のアセット
    vendor/assets：サードパーティー製のアセット

    これらにはそれぞれサブディレクトリがある。

  マニフェストファイル
    sprocketsというgemを使って、ブラウザにアセットをひとつにまとめて送る機能がある。

    無駄な通信のやり取りを防ぐための技術

    コメントで記述されている
    *= require_self
    *= require_tree .
    などがこれで、treeはマニフェストファイルがあるディリ区鳥以下のものすべてを読み込んでくださいという記述。
    selfは自身のcssファイルを読み込んでくださいという記述である。

  プリプロセッサエンジン

  いわゆるerb sass coffeeなどのコンパイラである。
  また、プリプロセッサ電人はつなげて使用することができ、
  foobar.js.erb.coffeeなどとすることもできる。

７章４節：リンクとルート

結論。
<a href="static_pages/about">About</a>
よりも
<%=link_to "About", about_path%> (文字列,　名前付きルート)
のほうがいい。

ルーティングについて

get以外にmatchという指定の仕方もあり、こちらのほうが名前付きパスで指定する最スマートになる
なお、viaは現在必須となっている。基本的な書き方は

match 'top', to: 'home#top', via: 'get'

とし、viaに関してはgetかpostかを指定することが可能。

そして、これを変えたことにより、リンクを変くする必要がある。
基本的には名前付きパスで指定するものとする。

例えばルート（/）に指定するのであれば
root_path
になるし、先程の例のtopにアクセスするのであれば
top_path
となる。

７章５節：Modelの使い方

deviseを利用したmodelの実装

データベースを実験的に反映する場合は--sandboxモードを使用する。このため

rails c --sandbox
となる。

こうすることで直接的な変更はなくなるため、安全に様々な研究、実験をすることが可能となる。

7章６節：deviseのインストール

deviseをインストールした際は、必ず
config/enviroments/developmentに、

config.action_mailer.default_url_options = {host: 'localhost', port :3000}

を入れる。

deviseではフラッシュメッセージが必要になるが、今回の場合、bootstrapに装飾した形で返したいため、予めヘルパーを定義しておいた。

例えば、もしflash[:success]='welcome to the sample app!'ってなった場合、このkeyの部分をbootstrap_class_forの引数に取ることで、それぞれ対応する結果をヘルパーが返してくれるようになるため。結果としてスマートにスタイリングとテキストを嵌めこむことが可能になる。

7章7節：Userモデルの作成

rails g migrationでの便利な書き方として
hoge_users name:string
などとすると、自動的にusersの指定が入り、nameをadd_columnすることができる。（これは便利…）

validates (検証)について
基本的な指定の仕方
validates :colum, option

例えば、nameにから文字でないこと(presence)を検証するには
validates :name, presence: true
となる。

実際にrails c --sandboxでやってみると、saveの時にfalseを介してくることがわかる。

length: {maximum: 50}
という部分に関しては、分解してみてみると、多重配列になっていることがわかる
{length: {maximum: 50}}
つまり

validates :name, presence: true, length: {maximum: 50}
この一行をわかりやすく表現すると
validates(:name, {presence:true},{length: {maximum: 50}})
となる。

しっかりとバリデーションを設定することで、事故の防止に繋がる。

なお、deviseの設定自体は、config/initializers/devise.rbからいつでも参照することが可能。

７章８節：ユーザーを表示する

resourcesなusersが生成されていないので、コントローラーを生成し、resourcesを設定する。

そのままだとnewも反映されてしまうので、only:を使って限定的に指定する。

今回はgravaterというサービスを使用してプロフィールの写真として使っていく。

gravaterはプロフィール写真を共通管理するためのサービス。
ファイルのアップロードなどを考えずに済むので便利

gravatar_forヘルパーを作成し、登録しているプロフィール写真を呼び出せるように設定。

７章９節：deviseを利用したユーザー登録

deviseを利用するにあたって、基本的にビューの編集をする際は、app/views/devise直下のフォルダーを利用する。new editが入っているフォルダーはdevise/registrationsである。

7章１０節：サインインとサインアウト

current_userというメソッドでユーザーを取得することができる。

サインインしている時としていない時で条件分岐をして、表示を変更する必要がある。

headerのパーシャルに変更を加えることでこれは実現することが可能。

サインインしているかしていないかでパスを変更する。

bootstrapのjs部分についてだが、読み込みの順番がどうやらあるらしい、配置する順番に関しては気をつけること。先にjquery系を行い、次にbootstrap.そのあとにターボリンクなどを配置すると良い。

7章11節：ユーザー情報の変更

ユーザー編集ページ。

ユーザーの更新をする際は、views/registrations/editの編集を行う。

また、パスの指定は、edit_user_path(current_user)という風に設定を追加するだけで可能（なぜcurrent_userで可能かは後ほど調べることにします。）

また、registrations_controllerでは、account_update_paramsをオーバーライドして設定を追加してあげる。今回の場合は、nameもpermitに追加した形で渡している…はずです。

すでに当人のみが編集でき、validatesも最初に地点で設定が完了しているため、編集皇帝はこれにて終了となる。














































end
